---
output:
  pdf_document: default
  html_document: default
---

```{r global_options, include = FALSE}
knitr::opts_chunk$set(echo = FALSE, warning = FALSE, message = FALSE)
library(printr)
```

# Conceitos da Ciência de Dados e R

Os conceitos que se desenvolverem aqui são os que são necessários para entendimento do uso das ferramentas de programação como R para resolver problemas práticas da ciência ou dos negócios. Já vimos uma introdução aos alguns desses conceitos no Capitulo *Primeiros Exercícios*. Algumas coisas vão repetir o que você já viu nos capítulos anteriores, mas numa forma mais organizada.

## Processo e Fluxo de Trabalho de Análises em R

Qualquer projeto que precisa as ferramentas da ciência de dados tem uma forma e fluxo de trabalho parecida. O diagrama seguinte mostra este processo: [^7]

```{r process_w, echo = FALSE, fig.align='center', fig.cap = "Processo de Programação com R"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/wickham_process.png")
```

[^7]: Wickham, Hadley & Grolemund, Garrett, **R for Data Science** (O'Reilly, Sebastopol, CA, January 2017).

O primeiro passo em qualquer análise em R é para **importar** os dados que vai analisar. O fonte mais popular nestes dias atuais é Microsoft Excel. Aqui nós vamos aprender como importar arquivos nos formatos `.csv` ou `xlsx` (ou seu primo mais antigo `.xls`) usando funções do Tidyverse.

Com os dados na memória de R como objeto, o próximo passo é para **arrumar** eles. Esta fase do trabalho inclui a descoberta dos erros de recordação, decidir o que fazer com variáveis que têm dados faltando (dados `NA`). Você precisa também ver se as variáveis têm valores bem fora dos valores esperados (*outliers*) e também decidir como tratar eles. Finalmente, aqui você pode acertar que os dados ficam *tidy*, ou seja, num formato consistente em que toda coluna é uma variável, toda linha uma observação e que cada conjunto de dados (`data.frame` ou `tibble`) só contem um tipo de dados. Essa consistência deixa você focar na análise e as questões que você quer responder sem precisar fazer uma nova limpeza ou arrumação. Surpreendentemente, esta fase de arrumar dados ocupa mais tempo que o tempo necessário para fazer as análises; leva até 70% do tempo inteiro que vai investir no projeto.

Uma vez que esses primeiros passos são completos, pode estudar as questões que motivaram o projeto no primeiro lugar. Nesta fase, o seu trabalho é cíclico. Você vai preparar um conjunto de dados menor que põe o foco nas observações que ajudam você responder à questão de interesse. As vezes, vai precisar transformar a escala ou unidade dos dados para facilitar a análise. Todo este processo de fazer um subconjunto do dados está chamada da fase de **transformação**. 

Com os dados transformados, você pode explorar eles para entender a distribuição dos valores e a relação entre as variáveis. Nesta fase de **visualização**, você usa gráficos e tabelas para ver as possíveis abordagens dos modelos. Quando tem uma boa ideia da estrutura dos dados, pode experimentar um **modelo**. Quando você examina o resultados dos modelos, pode perceber que existem métodos de análise que produzirem respostas mais exatas às suas perguntas. Também pode ver se os resultados cumprem as premissas do modelo usado. Todos os modelos têm premissas que os dados devem seguir. Senão, precisa usar um outro tipo de modelo que permite o uso do conjunto dos dados que você está empregando.

É assim que essas fases de *transformação-visualização-modelagem* formam um ciclo. Você explora os dados e conduza as análises repetitivamente até que você consegue responder para sua pergunta. 

Ao final, você deve fazer uma **reportagem** das análises. Uma análise sem um relatório é como o Koan zen que pergunta qual é o som de uma mão batendo palmas. Talvez produz grande iluminação pessoal mas não para os outros.

## Programação como Princípio Organizacional

Você vai combinar todos esses passos em 1 ou mais programas ou scripts. Como descrevi antes, o poder de um programa para executar suas análises de dados é que você e outros podem entender o que você fez para organizar os dados e analisar eles. 

## Importar Dados para R

### `read_csv()` --- Arquivos .csv 

Já apresentei o uso de `readr::read_csv()` (o nome de um pacote seguido por 2 dois pontos e o nome de uma função é usado em R para especificar qual versão desse nome você quer usar ou, como neste caso, para enfatizar de qual pacote a função vem) em relação dos dados de inflamação. Vamos aplicar esta função para o caso de preços de 2 ações em 2013, Starbucks (SBUX) e Apple (AAPL).


A tela de `Help` para `readr::read_csv()` mostra os seguintes argumentos. `read_csv` faz parte de um grupo de funções que traduzem arquivos externos em *tibbles* (data frames com habilidades adicionais) de R. 

```{r read_csv, echo = FALSE, fig.align='center', fig.cap = "Help - read_csv"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/read_csv_help.png")
```

Você pode ler a página para entender como usar todos os argumentos. Aqui são as primeiras linhas do arquivo `.csv` em Excel. 

```{r stockprice_excel, echo = FALSE, fig.align='center', fig.cap = "Excel - stockprice.csv"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/stockprice_Excel.png")
```

Porque o padrão para o argumento `col_names` é `TRUE`, neste caso, podemos deixar a função importar as palavras na primeira linha como os nomes de variáveis. Se você não quer usar os nomes do Excel, pode mudar o argumento para `FALSE`, como fizemos no último capitulo. Também, `readr` tentará interpretar quais são as classes dos valores nas colunas, utilizando os primeiras 100 linhas para determinar se são caráteres, números, datas, ou valores lógicos. Você pode controlar os tipos de colunas com o argumento `col_types`. Neste caso, se quisemos, podemos especificar as colunas como `col_types = c(D,n,n)` (data, número, número) como esta figura mostra.

```{r col_types_help, echo = FALSE, fig.align='center', fig.cap = "Tipos de Coluna"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/col_types_help.png")
```

Para importar o arquivo dos preços de ações, podemos confiar que `read_csv()` vai reconhecer corretamente os tipos das colunas e que queremos os nomes na primeira linha como nomes das variáveis na base de dados. Podemos então usar uma forma simples do comando. Você pode ver que o tibble que resulta tem as classes (tipos) de variáveis corretos.

**VSS** *Se você tem o seu arquivo `.csv` com números do estilo brasileiro (com uma vírgula como o separador entre a mantissa e as casas decimais), você precisa usar a versão da função `read_csv2()`*. Esta versão da função separa os valores com um ponto e vírgula e reserva a vírgula usado sozinho para separador decimal.

```{r imp_stocks, echo = TRUE}
acoes <- readr::read_csv("stockprice.csv")
str(acoes)
```

Quando discutimos a limpeza dos dados, nós vamos transformar a variável `Date` para uma variável do tipo `Date` para que possamos utilizar em cálculos das datas. `read_csv()` somente importa como uma cadeia de caracteres se você não especifica uma sequência dos tipos de coluna porque existem tantos maneiras para retratar datas no mundo inteiro que R não tenta de adivinhar qual é o formato usado.

### Planilhas de Excel

O sistema `tidyverse` inclui um pacote que facilita importar os dados diretamente de uma planilha do Excel. Pode importar ou uma do tipo moderno de `.xlsx` ou do tipo antigo `.xls`. O comando `read_excel()` fica no pacote `readxl`. `read_excel()` tenta adivinhar qual é o tipo de arquivo que você abre. Se tiver problemas com o arquivo, você pode usar ou `read_xlsx` ou `read_xls` diretamente para abrir aquele tipo de arquivo. 

Para demonstrar esta função, eu vou usar um arquivo derivado de um projeto verdadeiro de pesquisa em que estou envolvido sobre a doença HIV. A planilha mostra alguns dados sobre os pacientes e sobre os resultados dos exames que eles fizeram ao início do estudo. Esta planilha, `pac_demo.xlsx` tem duas folhas. A primeira, `pac_demo`, contem os dados. A segunda folha, `data_dic` tem a dicionário dos dados, ou seja, uma lista dos nomes das variáveis, os seus tipos, e uma explicação textural do conteúdo. 

```{r data_dic, echo = FALSE, fig.align='center', fig.cap = "Diccionário dos Dados"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/data_dic.png")
```

**VSS** *É sempre uma boa praxe criar uma dicionário dos dados para seu trabalho.* Pode ser no formato em que você grava os dados inicialmente (e.g., Excel), em R ou até num caderno. Vale muito a pena para ajudar você e outros entender e reproduzir os seus resultados.

A função `read_excel()` funciona muito semelhante a função `read_csv`. Você especifica o arquivo para ser importado, o nome da folha (diferentemente de uma arquivo `.csv`, que não tem folhas), uma cadeia de caracteres para os tipos das colunas, além das outras opções que pode consultar na tela de `Help`.

```{r read_excel_file, echo = TRUE}
pac_data <- readxl::read_excel("pac_demo.xlsx", sheet = "pac_demo")
tibble::glimpse(pac_data)
```

No passado com R e até hoje com outras linguagens, foi considerado necessário salvar uma planilha em `.csv` antes de importar. Com o pacote `readxl`, este passo não é mais necessário. Pode importar diretamente da planilha original.

### Nomes dos Objetos em R

Nomes dos objetos (variáveis, funções, etc.) em R devem começar com uma letra e contem só letras, números, `_` (caractere de sublinhado), e `.` (ponto final). 

Além disso, nomes devem ser descritivos para que você lembra o que você está fazendo e para outros o conhecem facilmente. Assim, você provavelmente vai querer combinar mais que uma palavra. Para fazer isso, existem alternativas que vários programadores usam:

1. combine_palavras_assim (*snake case*)
2. useMaiusculosMinusculos (*camel case*)
3. usar.pontos.entre.palavras

Minha preferência é para #1, *snake case* porque não precisa mexer com as letras maiúsculos e inclui um pouco de espaço entre as palavras. Experiência mostra que qualquer opção você escolhe, seja consistente no uso dele.

Também, R e todas as outras linguagens de programação são muitos bravas sobre a ortografia das palavras. Se você não escreve o nome de um objeto exatamente na forma que você o designou originalmente, R não vai o reconhecer e vai retornar um erro.  

```{r nomes_erros, echo = TRUE}
r_designacao <- 26 * 37
# agora quero ver o valor
```

```{r spell, echo = FALSE, fig.align='center', fig.cap = "Erros de r_designacao"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/spelling_erro.png")
```

Essas duas tentativas não deram certas. A primeira substituiu um ponto para o sublinhado e o segundo corrigiu este erro mas usou um "D" maiúsculo. Entretanto, se teclamos o nome certo ...

```{r no_erro}
r_designacao
# Finalmente, o valor

```

A diferença em só 1 caractere é suficiente para confundir R e produz o erro. Também, R distingue entre letras minusculas e letras maiúsculas. **VSS** *Prestem atenção nos detalhes dos nomes dos objetos.* 

Na luta para lembrar e grafar os nomes dos objetos corretamente, RStudio pode ajudar você com 2 atalhos. Primeiro, se você escreve os primeiros caráteres de um nome e toca na tecla <TAB>, RStudio vai dar uma lista dos objetos (variáveis, data frames, tibbles e funções) que começam com este sequência dos caráteres. A figura seguinte mostra esta ajuda. Selecione o nome que você quer e toca no <TAB> de novo. RStudio vai completar o nome.

```{r name_help, echo = FALSE, fig.align='center', fig.cap = "<TAB> Ajuda com Nomes"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/name_choice.png")
```

Segundo, se você tecla uma linha de código complicado e fazer um erro, mas não quer teclar toda a linha de novo, RStudio pode ajudar você. O software lembra todas as linhas de código que você já escreveu. Se você escreve só os primeiros caráteres da linha e toca nas teclas <CMD/CTRL> + <SETA-PARA-CIMA> e RStudio mostrará as últimas linhas de código que usam estes caráteres ao início. No exemplo seguinte, uma linha de código de um projeto de pesquisa meu, teclei o nome de um objeto como `trpl_new` e R retornou um erro. Eu quis `prpl_new`. Invés de escrever toda a linha de novo, posso tocar a combinação de <CMD/CTRL> + <SETA-PARA-CIMA> no Console (não na janela de programação), e a historia dos comandos aparecerá. Selecione a linha que você quer inserir, faça sua correção e executar. Se a linha de código que você quer repetir (para corrigir) é a última, existe uma versão simplificada deste truque: só toque na tecla de <SETA-PARA-CIMA> e a última linha vai aparacer no Console. Finalmente, você pode ver todas as linhas que você já executou, mesmo se eles vieram das sessões de trabalho anteriores na aba `History` da janela a cima para direta como a figura seguinte mostra. [^8] 

[^8]: É difícil de mostrar isso num documento. Criarei um vídeo no canal de YouTube para demonstrar como funciona este ajuda histórica.

```{r history, echo = FALSE, fig.align='center', fig.cap = "<TAB> Janela de History"}
knitr::include_graphics("~/Documents/Sustentare/Data_Analysis_with_R/dawR1/history.png")
```

